package uk.co.essarsoftware.par.cards;

import java.util.*;
import java.util.stream.Stream;

/**
 * A pack of {@link Card}s. May be generated either as a standard 52-card pack without jokers, or a 54-card pack containing two jokers.
 * A pack is internally identified by a unique ID, that is embedded into all cards generated by the pack. A card generated from a pack is considered equal
 * only if it is compared to a card object from the same pack, with the same {@link Suit} and {@link Value}.
 * @author essar
 */
public class Pack
{

    private final HashSet<PackEntry> cards;
    private final UUID packID;

    /**
     * Creates a new pack. Cannot be called externally, use {@link #generatePack()} or {@link #generatePackWithJokers()} instead.
     */
    private Pack() {

        cards = new HashSet<>();
        packID = UUID.randomUUID();

    }

    /**
     * Creates a new Card and adds it to this Pack.
     * @param s the card Suit.
     * @param v the card Value.
     * @throws IllegalArgumentException if an attempt is made to add duplicate cards to the pack.
     */
    private void addCard(Suit s, Value v) {

        // Create a new internal card 
        PackEntry card = new PackCard(s, v);

        synchronized (cards) {

            // Check if card is already in the pack
            if (cards.contains(card)) {

                throw new IllegalArgumentException(String.format("Duplicate card detected (%s)", card));

            }

            // Add to the cards list
            cards.add(card);

        }
    }

    /**
     * Creates a new Joker and adds it to this Pack.
     */
    private void addJoker() {

        // Create a new internal card 
        PackEntry joker = new PackUnboundJoker();
        
        synchronized (cards) {

            // Add to the cards list
            cards.add(joker);

        }
    }

    /**
     * Gets a Stream object containing all the cards in this Pack.
     * @return a Stream of Cards.
     */
    Stream<? extends Card> getCardStream() {

        return cards.stream();

    }

    /**
     * Gets an array containing all the cards in this Pack.
     * @return an array of Cards.
     */
    public Card[] getCards() {

        return cards.stream().toArray(Card[]::new);

    }

    /**
     * Gets the unique pack ID.
     * @return a UUID that is unique for this pack.
     */
    public UUID getPackID() {

        return packID;

    }

    /**
     * Generates a new Pack containing the standard set of 52 cards.
     * @return a new Pack of 52 cards.
     */
    public static Pack generatePack() {

        Pack pack = new Pack();
        Arrays.stream(
            Suit.values()).forEach(s -> Arrays.stream(
                Value.values()).forEach(v -> pack.addCard(s, v)));

        return pack;

    }

    /**
     * Generates a new pack containing the standard set of 52 cards plus two jokers.
     * @return a new Pack of 54 cards.
     */
    public static Pack generatePackWithJokers() {

        Pack pack = generatePack();
        pack.addJoker();
        pack.addJoker();

        return pack;

    }

    /**
     * Subinterface for Cards that are part of a Pack. Adds a pack identifier to each card.
     */
    private interface PackEntry extends Card
    {

        public UUID getPackID();

    }
        

    /**
     * Extension of a Card that is held in a Pack.
     */
    private class PackCard extends DefaultCard implements PackEntry
    {

        /**
         * Instantiates a new PackCard with the specified suit and value.
         * @param suit the card suit.
         * @param value the card face value.
         */
        private PackCard(Suit suit, Value value) {

            super(suit, value);

        }
        
        /**
         * @see PackEntry#getPackID()
         */
        @Override
        public UUID getPackID() {

            return Pack.this.getPackID();

        }

        /**
         * Tests if this PackCard is equal to another object.
         * @return {@code true} if {@code o} is a PackCard, with a matching pack ID, suit and value; {@code false} otherwise.
         * @see Object#equals(Object)
         */
        @Override
        public boolean equals(Object o) {

            if (o instanceof PackEntry) {

                PackEntry card = (PackEntry) o;
                // Must match pack ID, suit and value
                return Objects.equals(getPackID(), card.getPackID())
                    && Objects.equals(getSuit(), card.getSuit())
                    && Objects.equals(getValue(), card.getValue());

            }
            return false;

        }
    }

    /**
     * Extension of a bound joker that is held in a <tt>Pack</tt>.
     */
    private class PackBoundJoker extends BoundJoker implements PackEntry
    {
        /**
         * Instantiates a new PackBoundJoker bound to the specified Card.
         * @param card a Card to bind to this joker.
         */
        private PackBoundJoker(Card card) {

            super(card);

        }

        /**
         * @see PackEntry#getPackID()
         */
        @Override
        public UUID getPackID() {

            return ((PackCard) getBoundCard()).getPackID();

        }
    }

    /**
     * Exetension of an unbound joker that is held in a Pack.
     */
    private class PackUnboundJoker extends UnboundJoker implements PackEntry
    {

        /**
         * @see UnboundJoker#createBoundJoker(Card)
         */
        @Override
        protected BoundJoker createBoundJoker(Card card) {

            // Can only bind to a pack card
            if (! (card instanceof PackCard)) {

                throw new IllegalArgumentException("Must bind to pack card");

            }

            return new PackBoundJoker(card);

        }

        /**
         * @see PackEntry#getPackID()
         */
        @Override
        public UUID getPackID() {

            return Pack.this.getPackID();

        }
    }
}
