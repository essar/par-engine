package uk.co.essarsoftware.par.cards;

import java.util.*;
import java.util.stream.Stream;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A pack of {@link Card}s. May be generated either as a standard 52-card pack without jokers, or a 54-card pack containing two jokers.
 * A pack is internally identified by a unique ID, that is embedded into all cards generated by the pack. A card generated from a pack is considered equal
 * only if it is compared to a card object from the same pack, with the same {@link Suit} and {@link Value}.
 * @author essar
 */
public class Pack
{

    private static final Logger _LOGGER = LoggerFactory.getLogger(Pack.class);

    private final HashSet<PackEntry> cards;
    private final UUID packID;

    /**
     * Create a new pack. Cannot be called externally, use {@link #generatePack()} or {@link #generatePackWithJokers()} instead.
     */
    private Pack() {

        cards = new HashSet<>();
        packID = UUID.randomUUID();

        _LOGGER.debug("Pack {} initialized", packID);

    }

    /**
     * Create a new Card and adds it to this Pack.
     * @param s the card Suit.
     * @param v the card Value.
     */
    private void addCard(Suit s, Value v) {

        // Create a new internal card and add to the pack
        addEntry(new PackCard(s, v));
        
    }

    /**
     * Create a new Joker and adds it to this Pack.
     */
    private void addJoker() {

        // Create a new internal joker and add to the pack
        addEntry(new PackUnboundJoker());
        
    }

    /**
     * Add an entry (card or joker) to this Pack.
     * @param entry the card or joker to add.
     * @throws IllegalArgumentException if an attempt is made to add a card that is not associated with this pack or add duplicate cards to the pack.
     */
    void addEntry(PackEntry entry) {

        _LOGGER.trace("addEntry({})", entry);

        // Check if the entry belongs to the pack
        if (getPackID() != entry.getPackID()) {

            throw new IllegalArgumentException(String.format("Pack ID mismatch (%s)", entry.getPackID()));

        }

        synchronized (cards) {
            
            // Check if the entry is already in the pack
            if (cards.contains(entry)) {

                throw new IllegalArgumentException(String.format("Duplicate entry detected (%s)", entry));

            }

            // Add to the cards list
            cards.add(entry);
            _LOGGER.debug("[{}] pack entry added: {}", packID, entry);

        }
    }

    /**
     * Get a Stream object containing all the cards in this Pack.
     * @return a Stream of Cards.
     */
    Stream<? extends Card> getCardStream() {

        return cards.stream();

    }

    /**
     * Get an array containing all the cards in this Pack.
     * @return an array of Cards.
     */
    public Card[] getCards() {

        return cards.stream().toArray(Card[]::new);

    }

    /**
     * Get the unique pack ID.
     * @return a UUID that is unique for this pack.
     */
    public UUID getPackID() {

        return packID;

    }

    /**
     * Generate a new Pack containing the standard set of 52 cards.
     * @return a new Pack of 52 cards.
     */
    public static Pack generatePack() {

        Pack pack = new Pack();
        Arrays.stream(
            Suit.values()).forEach(s -> Arrays.stream(
                Value.values()).forEach(v -> pack.addCard(s, v)));

        return pack;

    }

    /**
     * Generate a new pack containing the standard set of 52 cards plus two jokers.
     * @return a new Pack of 54 cards.
     */
    public static Pack generatePackWithJokers() {

        Pack pack = generatePack();
        pack.addJoker();
        pack.addJoker();

        return pack;

    }

    /**
     * Subinterface for Cards that are part of a Pack. Adds a pack identifier to each card.
     */
    private interface PackEntry extends Card
    {

        public UUID getPackID();

    }
        

    /**
     * Extension of a Card that is held in a Pack.
     */
    class PackCard extends DefaultCard implements PackEntry
    {

        /**
         * Instantiate a new PackCard with the specified suit and value.
         * @param suit the card suit.
         * @param value the card face value.
         */
        private PackCard(Suit suit, Value value) {

            super(suit, value);

        }
        
        /**
         * @see PackEntry#getPackID()
         */
        @Override
        public UUID getPackID() {

            return Pack.this.getPackID();

        }

        /**
         * Test if this PackCard is equal to another object.
         * @return {@code true} if {@code o} is a PackCard, with a matching pack ID, suit and value; {@code false} otherwise.
         * @see Object#equals(Object)
         */
        @Override
        public boolean equals(Object o) {

            if (o instanceof PackEntry) {

                PackEntry card = (PackEntry) o;
                // Must match pack ID, suit and value
                return Objects.equals(getPackID(), card.getPackID())
                    && Objects.equals(getSuit(), card.getSuit())
                    && Objects.equals(getValue(), card.getValue());

            }
            return false;

        }

        /*
         * @see DefaultCard#toString
         */
        @Override
        public String toString() {

            return String.format("PackCard@%s[packId=%s,suit=%s,value=%s]", getCardID(), packID, getSuit(), getValue());
            
        }
    }

    /**
     * Extension of a bound joker that is held in a <tt>Pack</tt>.
     */
    class PackBoundJoker extends BoundJoker implements PackEntry
    {
        /**
         * Instantiates a new PackBoundJoker bound to the specified Card.
         * @param card a Card to bind to this joker.
         */
        private PackBoundJoker(Card card) {

            super(card);

        }

        /**
         * @see PackEntry#getPackID()
         */
        @Override
        public UUID getPackID() {

            return ((PackCard) getBoundCard()).getPackID();

        }
    }

    /**
     * Exetension of an unbound joker that is held in a Pack.
     */
    class PackUnboundJoker extends UnboundJoker implements PackEntry
    {

        /**
         * @see UnboundJoker#createBoundJoker(Card)
         */
        @Override
        protected BoundJoker createBoundJoker(Card card) {

            _LOGGER.trace("createBoundJoker({})", card);

            // Can only bind to a pack card
            if (! (card instanceof PackCard)) {

                throw new IllegalArgumentException("Must bind to pack card");

            }

            PackBoundJoker boundJoker = new PackBoundJoker(card);
            _LOGGER.debug("[%s] Created bound joker: {}", packID, boundJoker);
            
            return boundJoker;

        }

        /**
         * @see PackEntry#getPackID()
         */
        @Override
        public UUID getPackID() {

            return Pack.this.getPackID();

        }
    }
}
